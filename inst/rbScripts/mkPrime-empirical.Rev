clear() # Just whilst debugging

neo <- readDiscreteCharacterData("matrices/project2800.neo.nex")
trans <- readDiscreteCharacterData("matrices/project2800.trans.nex")
logFile = "rbOut/project2800-mkp.log"
treeFile = "rbOut/project2800-mkp.trees"

# Separate Neomorphic and transformational partitions
partitioned[1] <- neo
partitioned[2] <- trans

# Dataset properties
taxa <- neo.names()
outgroup <- clade(taxa[1])
nTaxa <- neo.size()
nEdge <- 2 * nTaxa - 3

moves = VectorMoves()


# Uniform prior on tree topologies
topology ~ dnUniformTopology(taxa, outgroup = outgroup)
moves.append( mvNNI(topology, weight = nEdge/2.0) )
moves.append( mvSPR(topology, weight = nEdge/10.0) )

# Compound dirichlet prior on edge length variability
# See https://revbayes.github.io/tutorials/ctmc/
# Prior mean tree length should be within a couple of orders of magnitude of the
# true value (Zhang, Rannala & Yang, 2012); one change per site should be okay?

gamma_shape <- 2
exp_steps <- 1 # Expected changes per site across the tree.
tree_length ~ dnGamma(shape = gamma_shape, rate = gamma_shape / exp_steps)
moves.append( mvScale(tree_length) )

rel_br_lengths ~ dnDirichlet( rep(1.0, nEdge) )
moves.append( mvBetaSimplex(rel_br_lengths, weight=nEdge) )
moves.append( mvDirichletSimplex(rel_br_lengths, weight=nEdge/10.0) )
br_lengths := rel_br_lengths * tree_length

phylogeny := treeAssembly(topology, br_lengths)


# Log-normal distributed rate variation (Wagner 2012, doi: 10.1098/rsbl.2011.0523)
# rate_log_sd ~ dnGamma( 1, 1 )
# moves.append( mvScale(rate_log_sd, lambda=1, weight=2.0) )

# Mean = 1, so that tree length ~ character changes
# 6 categories (see Wright & Wynd 2024,
# https://www.biorxiv.org/content/10.1101/2024.06.26.600858v1)
# rate_categories := fnDiscretizeDistribution( dnLognormal( 0, rate_log_sd ), 6)


# Simple M2 partition for neomorphic characters
# Later, add siteRates=rate_categories
m_morph[1] ~ dnPhyloCTMC(tree=phylogeny, Q=fnJC(2), type="Standard", coding="variable") # informative preferable, but slower


# Partition transformational characters by number of states (k)
maxK = 10
partition = 1

u ~ dnGamma( 1, 1 )
moves.append( mvScale( u, lambda = 1, weight = 2.0) )
u

function fnMKPrime(n) {
  for (i in 1:n) {
    rates[i] = rep(1, n + 1)
    rates[i][i] = 0
    rates[i][n + 1] = u
  }
  rates[n + 1] = rep(1, n + 1)
  rates[n + 1][n + 1] = 0
  fnFreeK(rates)
}
fnMKPrime(2)

for (k in 2:maxK) {
  transByState[k] <- partitioned[2]
  transByState[k].setNumStatesPartition(k)
  nc = transByState[k].nchar()
  
  if (nc > 0) {
    
    rates := [ [0.0, 1],
               [1, 0.0] ]
    q[idx] := fnFreeK(rates) # == fnJC(2)
    m_morph[idx + 1] ~ dnPhyloCTMC(
      tree=phylogeny,
      # later: siteRates=rate_categories,
      Q=q[idx],
      type="Standard",
      coding="variable") # informative preferable, but slower
    m_morph[idx + 1].clamp(transByState[k - 1])
    idx = idx + 1
  }
}


# Conduct MCMC analysis
mymodel = model(phylogeny)

monitors = VectorMonitors()

monitors.append( mnModel(filename=logFile, printgen=5) )
monitors.append( mnModel(filename=paramFile, printgen=5, stochasticOnly = TRUE, posterior = FALSE, likelihood = FALSE, prior = FALSE, exclude = ["rel_br_lengths"]) )
monitors.append( mnFile(filename=treeFile, printgen=5, phylogeny) )
monitors.append( mnScreen(printgen=50, prior = FALSE, posterior = FALSE, rate_neo, rate_loss) )

mymc3 = mcmcmc(mymodel, monitors, moves, nruns=4, tuneHeat = TRUE, swapMethod = "both", swapMode = "multiple", combine="mixed")
mymc3.run(rules = stopping_rules, tuningInterval=200, checkpointFile = ckpFile, checkpointInterval = checkFreq)

```
