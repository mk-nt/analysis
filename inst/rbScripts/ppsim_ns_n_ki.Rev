print("Timestamp:", time("year"), time("day"), time("seconds"))
seed(0)

pid = args[1]
script = "ns_n_ki"
scriptBase = pid + "_" + script
burnin = args[2]
atStat = args[3]
thin = 24

for (runID in 1:2) {
  runBase = scriptBase + "_run_" + runID
  print("Reading run:", runBase)
  
  trees = readTreeTrace(runBase + ".trees", burnin = burnin,
                        thinning = thin).getTrees()
  params = readTrace(scriptBase + ".p_run_" + runID + ".log",
                     burnin = burnin, thinning = thin)
  params
  p_rate_log_sd = params[5].getValues()
  p_rate_loss = abs(params[6].getValues())
  p_root_freq_1 = params[7].getValues()
  p_root_freq_2 = params[8].getValues()
  p_tree_length = params[9].getValues()
  
  n_iter = min(v(p_rate_loss.size(), trees.size()))
  for (i in 1:n_iter) {
    rate_log_sd = p_rate_log_sd[i]
    rate_loss = p_rate_loss[i]
    rate_categories := fnDiscretizeDistribution( dnLognormal( 0, rate_log_sd ), 6)
    rate01 := 2 / (1 + rate_loss)
    rate10 := 2 * rate_loss / (1 + rate_loss)
    rates := [ [0.0, rate01],
               [rate10, 0.0] ]
    neoQ := fnFreeK(rates)
    if (atStat == "stat") {
      root_freqs := Simplex( rate10, rate01 ) # The stationary distribution
    } else {
      root_freqs = abs([p_root_freq_1[i], p_root_freq_2[i]]); # Inferred
    }
    
    m_neo ~ dnPhyloCTMC(
      tree = trees[i],
      siteRates = rate_categories,
      Q = neoQ,
      nSites = 1024,
      rootFrequencies = root_freqs,
      type = "Standard",
      coding = "informative"
    )
    print("Simulated matrix #", i)
    # Export simulated matrix by printing to stdout
    # It would perhaps have been better to do writeNexus(someFile, m_neo)
    m_neo.show()
  }
}
print("Simulated matrix #", "# # # END # # #")
print("Timestamp:", time("year"), time("day"), time("seconds"))
q()
