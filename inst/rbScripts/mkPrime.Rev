clear() # Just whilst debugging

# Initialize variables
logFile = "rbOut/k5obs4.mkp.log"
paramFile = "rbOut/k5obs4.mkp.p.log"
ckpFile = "rbOut/k5obs4.mkp.ckp"
dotFile = "rbOut/k5obs4.mkp.model"
treeFile = "rbOut/k5obs4.mkp.trees"
moves = VectorMoves()

# Load character data
chars <- readDiscreteCharacterData("simmat/k5obs4.nex")
taxa <- chars.names()
outgroup <- clade(taxa[1])
nTaxa <- chars.size()
nEdge <- 2 * nTaxa - 3
print("Read", chars.nchar(), "characters for", nTaxa, "taxa, with outgroup", taxa[1])


# Uniform prior on tree topologies
topology ~ dnUniformTopology(taxa, outgroup = outgroup)
moves.append( mvNNI(topology, weight = nEdge/2.0, tuneTarget = 0.26) )
moves.append( mvSPR(topology, weight = nEdge/10.0, tuneTarget = 0.26) )

# Compound dirichlet prior on edge length variability
# See https://revbayes.github.io/tutorials/ctmc/
# Prior mean tree length should be within a couple of orders of magnitude of the
# true value (Zhang, Rannala & Yang, 2012); one change per site should be okay?

gamma_shape <- 2
exp_steps <- 3 # Expected changes per site across the tree.
tree_length ~ dnGamma(shape = gamma_shape, rate = gamma_shape / exp_steps)
moves.append( mvSlice(tree_length, tuneTarget = 0.26) )

rel_br_lengths ~ dnDirichlet( rep(1.0, nEdge) )
moves.append( mvBetaSimplex(rel_br_lengths, weight = nEdge / 5.0, tuneTarget = 0.26) )
moves.append( mvDirichletSimplex(rel_br_lengths, weight = nEdge / 10.0, tuneTarget = 0.26) )
br_lengths := rel_br_lengths * tree_length

phylogeny := treeAssembly(topology, br_lengths)


# Log-normal distributed rate variation (Wagner 2012, doi: 10.1098/rsbl.2011.0523)
# rate_log_sd ~ dnGamma( 1, 1 )
# moves.append( mvSlice(rate_log_sd, weight=2.0, tuneTarget = 0.26) )

# Mean = 1, so that tree length ~ character changes
# 6 categories (see Wright & Wynd 2024,
# https://www.biorxiv.org/content/10.1101/2024.06.26.600858v1)
# rate_categories := fnDiscretizeDistribution( dnLognormal( 0, rate_log_sd ), 6)

# Partition transformational characters by number of states (k)
u ~ dnGamma( shape = 1, rate = 1 )
moves.append( mvSlice( u, weight = 2.0, tuneTarget = 0.26) )

# Mk prime matrix
# If we want to allow different values of k, we should do this using loops,
# rather than a single function
k <- 4
rates := [ [0, 1, 1, 1, u],
           [1, 0, 1, 1, u],
           [1, 1, 0, 1, u],
           [1, 1, 1, 0, u],
           [1, 1, 1, 1, 0]]

Q4prime := fnFreeK(rates)

root_u ~ dnGamma( shape = 1, rate = 1)
moves.append( mvSlice ( root_u ) )

q4Stationary := Simplex(1, 1, 1, 1, u)
q4Root := Simplex(1, 1, 1, 1, u * root_u)

# branchRates = 1?
m_morph[1] ~ dnPhyloCTMC(
    tree = phylogeny,
    Q = Q4prime,
    rootFrequencies = q4Root,
    type = "Standard",
    coding = "variable"
) # coding = "informative" is slower, and ?potentially problematic?
m_morph[1].clamp(chars)
m_morph[1].lnProbability()

condRates := [ [ 0, u],
               [ k, 0] ]
Q4cond := fnFreeK(condRates)
stationaryCond := Simplex( k, u )
rootCond := Simplex( k, u * root_u )



print("Model object:")
m_morph[2] ~ dnInverse( dnPhyloCTMC(tree = phylogeny, Q = Q4cond, type = "Standard", rootFrequencies = rootCond))

condChars <- readDiscreteCharacterData("simmat/k5obs4-cond.nex")
print("Read", condChars.nchar(), "character masks")
m_morph[2].clamp(condChars)

lnL := m_morph[1].lnProbability() + m_morph[2].lnProbability()


u.clamp(0.001)
write(u, m_morph[1].lnProbability(), m_morph[2].lnProbability(), m_morph[1].lnProbability() + m_morph[2].lnProbability())
u.clamp(0.01)
write(u, m_morph[1].lnProbability(), m_morph[2].lnProbability(), m_morph[1].lnProbability() + m_morph[2].lnProbability())
u.clamp(0.1)
write(u, m_morph[1].lnProbability(), m_morph[2].lnProbability(), m_morph[1].lnProbability() + m_morph[2].lnProbability())
u.clamp(0.5)
write(u, m_morph[1].lnProbability(), m_morph[2].lnProbability(), m_morph[1].lnProbability() + m_morph[2].lnProbability())
u.clamp(0.8)
write(u, m_morph[1].lnProbability(), m_morph[2].lnProbability(), m_morph[1].lnProbability() + m_morph[2].lnProbability())
u.clamp(1)
write(u, m_morph[1].lnProbability(), m_morph[2].lnProbability(), m_morph[1].lnProbability() + m_morph[2].lnProbability())
u.clamp(1.3)
write(u, m_morph[1].lnProbability(), m_morph[2].lnProbability(), m_morph[1].lnProbability() + m_morph[2].lnProbability())
u.clamp(2)
write(u, m_morph[1].lnProbability(), m_morph[2].lnProbability(), m_morph[1].lnProbability() + m_morph[2].lnProbability())
u.clamp(4)
write(u, m_morph[1].lnProbability(), m_morph[2].lnProbability(), m_morph[1].lnProbability() + m_morph[2].lnProbability())

# Prepare MCMCMC analysis
printFreq = 500
logFreq = 1000

p1 := m_morph[1].lnProbability()
p2 := m_morph[2].lnProbability()
mymodel = model(phylogeny, p1, p2)
"NOT"
write("Writing model graph to ", dotFile)
#mymodel.graph(dotFile) # crashes

monitors = VectorMonitors()
monitors.append( mnScreen(printgen = printFreq, p1, p2, u, root_u, tree_length, likelihood = FALSE, posterior = FALSE, prior = FALSE) )
monitors.append( mnModel(filename = logFile, printgen = logFreq) )
monitors.append( mnModel(
    filename = paramFile,
    printgen = logFreq,
    stochasticOnly = TRUE,
    exclude = ["rel_br_lengths"]
    ) )
monitors.append( mnFile(filename = treeFile, printgen = logFreq, phylogeny) )

checkFreq = 1000
stopping_rules[1] = srMaxIteration(1000000)
stopping_rules[2] = srMinESS(1000, paramFile, checkFreq, "ESS")


print("Conduct analysis -", logFile)
mymc3 = mcmcmc(mymodel, monitors, moves, nruns = 2, nchains = 12, delta = 0.3, moveschedule = "single", swapMethod = "both", swapMode = "multiple", combine = "mixed")
#mymc3 = mcmc(mymodel, monitors, moves, nruns = 2, moveschedule = "single")
print ("Defined MCMC; running:")
# mymc3.run(generations = 10000) # Replace with mymc3.burnin()
mymc3.run(generations = 10) # Replace with mymc3.burnin()
mymc3.operatorSummary()
mymc3.run(generations = 35000) # Replace with mymc3.burnin()
mymc3.operatorSummary()


mymc3.run(rules = stopping_rules)
mymc3.operatorSummary()
if (FALSE) {
}
" # # # ENDS # # # "
