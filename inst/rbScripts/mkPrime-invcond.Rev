clear() # Just whilst debugging

# Initialize variables
logFile = "rbOut/k5obs4.mkpic.log"
paramFile = "rbOut/k5obs4.mkpic.p.log"
ckpFile = "rbOut/k5obs4.mkpic.ckp"
dotFile = "rbOut/k5obs4.mkpic.model"
treeFile = "rbOut/k5obs4.mkpic.trees"
moves = VectorMoves()

# Load character data
chars <- readDiscreteCharacterData("simmat/k5obs4.nex")
taxa <- chars.names()
outgroup <- clade(taxa[1])
nTaxa <- chars.size()
nEdge <- 2 * nTaxa - 3
print("Read", chars.nchar(), "characters for", nTaxa, "taxa, with outgroup", taxa[1])

condChars <- readDiscreteCharacterData("simmat/k5obs4-cond.nex")
print("Read", condChars.nchar(), "character masks")




# Uniform prior on tree topologies
topology ~ dnUniformTopology(taxa, outgroup = outgroup)
moves.append( mvNNI(topology, weight = nEdge/2.0, tuneTarget = 0.26) )
moves.append( mvSPR(topology, weight = nEdge/10.0, tuneTarget = 0.26) )

# Compound dirichlet prior on edge length variability
# See https://revbayes.github.io/tutorials/ctmc/
# Prior mean tree length should be within a couple of orders of magnitude of the
# true value (Zhang, Rannala & Yang, 2012); one change per site should be okay?

gamma_shape <- 2
exp_steps <- 3 # Expected changes per site across the tree.
tree_length ~ dnGamma(shape = gamma_shape, rate = gamma_shape / exp_steps)
moves.append( mvScale(tree_length, tuneTarget = 0.26) )

rel_br_lengths ~ dnDirichlet( rep(1.0, nEdge) )
moves.append( mvBetaSimplex(rel_br_lengths, weight = nEdge / 5.0, tuneTarget = 0.26) )
moves.append( mvDirichletSimplex(rel_br_lengths, weight = nEdge / 40.0, tuneTarget = 0.26) )
br_lengths := rel_br_lengths * tree_length

phylogeny := treeAssembly(topology, br_lengths)


# Log-normal distributed rate variation (Wagner 2012, doi: 10.1098/rsbl.2011.0523)
# rate_log_sd ~ dnGamma( 1, 1 )
# moves.append( mvScale(rate_log_sd, lambda=1, weight=2.0, tuneTarget = 0.26) )

# Mean = 1, so that tree length ~ character changes
# 6 categories (see Wright & Wynd 2024,
# https://www.biorxiv.org/content/10.1101/2024.06.26.600858v1)
# rate_categories := fnDiscretizeDistribution( dnLognormal( 0, rate_log_sd ), 6)

# Partition transformational characters by number of states (k)
u ~ dnGamma( shape = 1, rate = 1 )
moves.append( mvScale( u, lambda = 1, weight = 2.0, tuneTarget = 0.26) )


# Mk prime matrix
# If we want to allow different values of k, we should do this using loops,
# rather than a single function
k <- 4
rates := [ [0, 1, 1, 1, u],
           [1, 0, 1, 1, u],
           [1, 1, 0, 1, u],
           [1, 1, 1, 0, u],
           [1, 1, 1, 1, 0]]

Q4prime := fnFreeK(rates)
Q4prime

m_morph[1] ~ dnPhyloCTMC(
    tree = phylogeny,
    Q = Q4prime,
    type = "Standard",
    coding = "informative"
)
m_morph[1].clamp(chars)
m_morph[1].lnProbability()

condRates := [ [ 0, u],
               [ k, 0] ]
Q4cond := fnFreeK(condRates)
Q4cond
stationaryCond := Simplex( k, u )
stationaryCond

"Model object:"
m_morph[2] ~ dnInverse( dnPhyloCTMC(tree = phylogeny, Q = Q4cond, type = "Standard", rootFrequencies = stationaryCond))
m_morph[2].clamp(condChars)
print(m_morph[2])
m_morph[2].lnProbability()

"Dummy counterbalance:"
m_morph[3] ~ dnPhyloCTMC(tree = phylogeny, Q = Q4cond, type = "Standard", rootFrequencies = stationaryCond)
m_morph[3].clamp(condChars)
m_morph[3]


# Prepare MCMCMC analysis
mymodel = model(phylogeny)
write("Writing model graph to ", dotFile)
mymodel.graph(dotFile)

monitors = VectorMonitors()
monitors.append( mnModel(filename = logFile, printgen = 100) )
monitors.append( mnModel(
    filename = paramFile,
    printgen = 100,
    stochasticOnly = TRUE,
    exclude = ["rel_br_lengths"]
    ) )
monitors.append( mnFile(filename=treeFile, printgen = 100, phylogeny) )
monitors.append( mnScreen(printgen = 2000, u) )

checkFreq = 1000
stopping_rules[1] = srMaxIteration(1000000)
stopping_rules[2] = srMinESS(50, paramFile, checkFreq, "ESS")


print("Conduct analysis -", logFile)
#mymc3 = mcmcmc(mymodel, monitors, moves, nruns = 2, nchains = 6, moveschedule = "single", tuneHeat = FALSE, swapMethod = "both", swapMode = "multiple", combine = "mixed")
mymc3 = mcmcmc(mymodel, monitors, moves, nruns = 26, moveschedule = "single")
mymc3.run(generations = 10000)
mymc3.operatorSummary()
Q4prime
#mymc3.run(rules = stopping_rules, checkpointFile = ckpFile, checkpointInterval = checkFreq, tuningInterval = 20000)
#mymc3.operatorSummary()
" # # # ENDS # # # "
